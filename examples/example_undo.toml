# todo: make a real documentaion (wiki)
supported-shells = [
    "fish",
    "bash",
    "sh"
]

# This is an example undo file for a command called example, creates a file called 'example' in a directory, or $HOME if
# not provided, or deletes it:
#
# USAGE: example [--help --version --verbose] <command> <args>
#   commands:
#     do [--dir,-dir DIR=$HOME]         create the file DIR/example
#     dont [--dir,-d DIR=$HOME]         delete the file DIR/example

# Note the simple argument group pairing a long and short argument together and storing the given value and later
# referencing it. You can provide a variable name to store the argument value, and the longest provided argument name in
# all uppercase is used by default, if both a long and a short is provided, the long name is used.
#
# While many arguments will take a single value, other take none or take can take more then one. To specify the amount
# of arguments, you will want to prepend the argument with an optional identifier, a modifier and a colon.
# - ?: argument is a flag and takes no value
# - ...: argument takes one or more arguments
# - : argument takes exactly one value
#
# Also see the use of a
# ternary conditional. Here `DIR ? $DIR/example : ~/example` checks if a value was specified for DIR, and if so it will
# prepend that value to the
[[entry]]
cmd = 'example do [DIR:--dir,-d] [?:--verbose]'
undo = """rm % VERBOSE ? --verbose %
             % DIR ? "$DIR/example" : '~/example' %"""

# WARNING: in most cases something like this is impractical because there is no guarantee that there was no data written
# to the 'example' file; however, since the example command does not write to teh of 'example'  file after writing it
# and it is unlikely for any truly useful software to rely on such a file it is "sage" to recreate it here.
[[entry]]
cmd = "example dont [DIR:--dir,-d]"
undo = "test ! -example && touch % $DIR ? $DIR : '~' %/example"

# Here you can see a more complicated use case where you need to add some additional log to you undo pattern. Since the
# `mv` command may be use d to wither rename a file or move it to a new directory we must first check if the DST is a
# directory and move the file back to its original location, otherwise it was a rename and we can simply rename it. This
# can get tricky since we ned to conform to posix here so you undo rule1 can be used cross multiple platforms rather
# than just one shell like bash.
[[entry]]
cmd = "mv <SRC> <DST>"
undo = """test -d % DST %
            & mv % $DST %/$(basename % $SRC %) $(dirname % $SRC %)
            || mv % $DST % % $SRC %"""

# There is a pretty big flaw with the example above ; however, the `mv` command is able to take multiple arguments for
# the SRC positional parameter. To resolve this, add an ellipse (ie "...") to the end of the argument name, this will
# store the argument values in a list rather than as a single value. When using the values from that list you can either
# reference the entire list by including the ellipse or each individual item by excluding it. The pitfall here is that
# if you reference each item individually (even just once) you will force the command to be run once for each element,
# so it is preferable to use the list access whenever possible.
# todo: actually implement this style of elipse expansion
# todo: allow specifying a delimiter for the list values (often a space but can also be a comma)
[[entry]]
cmd = "mv <SRC...> <DST>"
undo = """test -d % DST %
            & mv % $DST %/$(basename % $SRC %) $(dirname % $SRC %)
            || mv % $DST % % $SRC %"""